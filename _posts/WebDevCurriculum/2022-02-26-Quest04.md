---
layout: post
title: "Quest04 OOP의 기본"
subtitle: ""
comments: true
categories : WebDevCurriculum
date: 2022-02-26
background: '/img/posts/06.jpg'
---

# Quest 04. OOP의 기본

## Introduction
* 이번 퀘스트에서는 바닐라 자바스크립트의 객체지향 프로그래밍에 대해 알아볼 예정입니다.
```
  앞으로 나올 질문들은 내용이 어마어마 한 것 같다. 질문 자체는 한 줄 이지만 얼마나 진지하게 작성하느냐에 따라 끝도 없이 쓸 수 있는 내용 들인 것 같다. 최대한 진지하게 작성 해보려고 한다.
```

## Topics
* 객체지향 프로그래밍
```
  객체지향 프로그래밍(OOP)?
    컴퓨터 프로그램을 객체들의 모임으로 파악하려는 프로그래밍 패러다임이다. 객체들은 서로 메시지를 주고 받을 수 있으며 데이터를 처리 할 수 있다.
  
  OOP의 장점은?
    프로그램을 유연하고 변경이 용이하게 만든다.
    직관적인 코드 분석을 가능하게 한다.
  
    위의 장점을 가능하게 하는 OOP의 중요한 특성은 강한 응집력과 약한 결합력을 지향 한다는 것이다.

    응집력 : 프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐 있는지를 나타내는 정도. 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고 지나치게 많은 일을 하지 않으면 그것을 응집력이 높다고 표현한다. 즉 하나의 클래스가 한 가지 업무만을 위해서 만들어져 있어야 한다. 예를 들어 carWindow라는 클래스는 차유리에 대한 기능만을 담당해야지 타이어에 대한 기능을 가지고 있어서는 안된다.

    결합력 : 프로그램 코드의 한 요소가 다른 요소에게 얼마나 의존적인지를 나타내는 정도. 한 요소가 다른 요소들과 관계를 크게 맺고 있지 않다는 것이다. 즉 클래스들이 혼자서 기능할 수 있어야 한다는 것이다. carWindow클래스는 carTier클래스와 별개의 클래스로 서로 영향을 주지 않고 기능 할 수 있어야 한다.
```
  * 프로토타입 기반 객체지향 프로그래밍
  [참고](https://evan-moon.github.io/2019/10/23/js-prototype/)
  
  ```
    질문의 의미는 프로토 타입에 대해서 얘기해보자는 것 같다. 그래서 프로토 타입에 대해서 써보려고 한다.
    ES6는 class를 지원하지만 결국엔 프로토타입으로 만든 함수다. 따라서 자바스크립트에서 oop를 구현하려면 결국엔 프로토 타입을 알아야 한다.

    프로토타입은 디자인 패턴이다.
      프로토 타입은 디자인 패턴일 뿐이다. 이를 채용한 다른 언어들도 많다. 그래서 먼저 디자인 패턴으로서의 프로토 타입을 알아본다.

      프로토타입 패턴은 객체를 효율적으로 생성하는 방법을 다루는 패턴 중 하나인데, 주로 객체를 생성하는 비용이 클 때 이를 회피하기 위해 사용된다. 원본 객체가 존재하고 이를 복사해서 새로운 객체를 생성하는 방법이다. 이렇게 하는 이유는 객체를 매번 생성하게 되면 똑같은 기능을 위해서 객체 생성비용을 계속 지불해야하기 때문이다. 객체지향언어인 자바에서도 이런 프로토타입 디자인 패턴을 사용한다. Cloneable 인터페이스를 사용하면 된다. 이렇게 객체를 복사하면 새로운 메모리 공간을 할당하지만 기존의 객체를 참조하게 된다. 얕은 복사의 개념이라고 보면 된다.

      이제는 자바스크립트의 프로토타입에 대해서 알아보자. 자바와 달리 자바스크립트는 프로토타입 패턴 언어이다. 따라서 객체를 생성하기만 해도 프로토타입 패턴이 적용된다. 그러니 자바스크립트의 객체가 무엇이고 객체가 생선된다는 것이 무엇을 의미하는 것인지 알아볼 필요가 있다.

      첫번째로 리터럴 객체 선언이 있다. 소스코드의 고정된 값을 대표하는 일종의 단축어 같은 개념이기 때문에 내부에서는 객체를 생성하는 일련의 매커니즘이 작동하고 있다. 자바스크립트는 일련의 메커니즘으로 함수(function)를 이용한다.

      두번째 방식인 함수로 객체를 생성해보자. new Object()와 같은 방식으로도 객체를 생성할 수 있는데 이는 생성자(Counstructor)를 사용하여 객체를 생성한다고 한다. 자바와 같은 클래스 기반 언어라면 Object클래스라고 볼 수 있지만 자바스크립트에서 Object는 함수다.

      지금까지 알아본 내용을 정리하면 다음과 같다.
      1. 프로토타입 패턴이란 객체를 생성할 때 원본 객체를 복제하여 생성하는 방법이다.
      2. 자바스크립트는 객체를 생성할 때 프로토타입 패턴을 사용한다.
      3. 자바스크립트틑 객체를 생성할 때 함수를 사용한다.

      function User () {}
      const evan = new User();
      console.log(evan); // User { __proto__: Object }
      console.log(typeof evan); // object

      위 코드를 보면 알 수 있듯이 지금까지 알아본 내용을 그대로 반영하고 있다. 객체 생성에는 함수를 사용했고 프토토타입 패턴을 활용하여 object를 복사해 객체를 생성했다. object를 복사 했다는 것의 의미는 User 함수의 프로토타입 객체를 복사했다는 의미다.

      만약 객체를 생성하면서 User 함수를 복제 했다면 생성된 객체는 object타입이 아니라 function이어야 한다. 따라서 함수가 아닌 다른 객체 타입의 무언가를 복제한 것이고 복제한 객체는 User 함수의 프로토 타입 객체인 것이다.

      constructor?
      함수를 선언하면 함수와 함께 해당 함수의 프로토타입 객체도 함께 생성되면 이 둘을 연결하게 된다. 이때 함수는 프로토타입 객체의 constructor 프로퍼티로 연결되고, 프로토타입 객체는 함수의 prototype 프로퍼티로 연결된다.

      prototype 프로퍼티의 constructor는 나를 만들 때 어떤 함수가 호출 되었냐를 의미한다. 만약 이 연결이 없다면 생성된 prototype 프로퍼티는 자신이 만들어 질 때 어떤 생성자 함수가 호출되었는지 알 수 없다.

      새롭게 생성된 객체는 자신이 생성될 때 어떤 원복 객체를 복사했는지에 대한 링크는 가지고 있지만 어떤 생성자가 호출되었는지에 대한 링크는 가지고 있지 않다. 그렇기 때문에 constructor 프로퍼티에 생성자 함수가 연결되어 있어 새롭게 만들어진 객체는 자신의 원본 객체에 접근해서 자신이 만들어질때 어떤 생성자 함수가 호출되었는지를 알 수 있다.

      다시 한 번 알아본 내용을 정리해보자. 
      1. 함수(A)를 생성하면 constructor함수(A-1)와 prototype 프로퍼티(A-2)가 생성된다.
      2. A함수를 new 연산자를 사용해 객체를 생성하면 A-1을 통해 어떤 함수를 통해 생성되었는지 알 수 있는 연결정보를 확인 할 수 있다.
      3. 또 A-2를 통해 어떤 객체를 복사하여 생성되었는지 알 수 있다.

      __proto__?
      construtor에 대한 설명중 함수를 통해 새롭게 생성된 객체는 원본 객체와의 연결을 가지고 있다는걸 알게 되었다. 이때 이 연결을 프로토타입 링크라고 한다.

      Object.prototype을 제외한 자바스크립트의 모든 객체는 원본 객체를 기반으로 복사되어 생성되기 때문에, 자신의 원본 객체로 연결되어 있는 프로토타입 링크를 모든 객체가 가지고 있다. 이때 이 링크가 담기는 프로퍼티가 __proto__이다.

      참고로 ES6이전에는 __proto__가 표준이었으나 이제는 Object.getPrototypeOf()를 사용하는 것이 좋다.

      User 함수를 사용하여 생성한 객체ㅐ는 User.prototype 객체를 복사하여 생성된 객체이기 때문에, 이 객체들은 원본인 User.prototype 객체를 자신의 __proto__ 프로퍼티에 연결해두는 것이다.

      프로토타입 체인?
      자바스크립트 내의 사용되는 모든 객체들은 전부 이런 프로토타입 기반 방식으로 정의되고 생성된다. 즉 String, Boolean, Array처럼 일반적으로 사용하는 빌트인 객체들도 모두 같은 방식을 사용해서 만들어졌다. 이렇게 프로토타입으로 이루어진 객체들의 관계를 프로토타입 체인 이라고 한다.
  ```
  * 자바스크립트 클래스
    ```
      객체를 생성하기 위한 템플릿이다. 데이터와 이를 조작하는 코드를 하나로 추상화한다. 프로토타입을 이용해서 만들어 졌지만 ES5의 클래스 의미와는 다른 문법과 의미를 가진다.

      클래스도 함수처럼 선언식과 표현식을 사용할 수 있다. 
      
      1. Class 선언
      class Rectangle{
        constructor(){
        }
      }
      2. Class 표현식
      let Rectangle = class{
        constructor(){
        }
      }

      위 코드에서 보듯이 함수와 굉장히 비슷한 특성을 가진다. 프로토타입 언어인 스크립트의 특성을 보여주는 것 같아서 프로토타입 공부가 중요하다는 생각이 든다. 참고로 function과 class는 뭔가 다른 것 같다. function과 class를 하나 씩 만들어서 prototype을 콘솔로 찍어보면 function은 그냥 function으로 나오는 반면에 class는 분명 class로 명시되어 나온다. 근데 또 typeof를 찍어보면 둘다 그냥 function으로 나온다. 앞으로 이런 부분에 대해서 알게 되면 이 부분은 지우도록 하겠지만 못 찾는 다면 남겨 놓고 언젠가는 해결해 보자. mdn 보면서 정리해보려고 했는데 역시 쉽지가 않더라. 지금 하기엔 좀 지치는 내용이라 시간을 두고 해보려고 한다. 

      ES6이전의 생성자와 class는 다음과 같은 차이점이 있다.
      1. 클래스는 함수로 호출될 수 없다.
      2. 클래스 선은은 let, const처럼 블록 스코프에 선언되며, 호이스팅이 일어나지 않는다.
      3. 클래스의 메소드 안에서 super키워드를 사용할 수 있다.
    ```
    * 생성자
    * 멤버 함수
    * 멤버 변수
  * 정보의 은폐
  ```
    캡슐화(encapsulation)라고도 할 수 있다.
      객체의 데이터를 외부에서 직접 접근하지 못하게 막고, 함수를 통해서만 조작이 가능하게 하는 작업이다.
      개념적으로 함수로만 접근할 수 있으면 속성 값이 임의로 변경되는 것을 막을 수 있기 때문에 좋을 수 있지만 현실적으로 코드양이 많이 늘어나게 된다. 롬복에 getter, setter가 있는 이유도 이런 귀찮은 작업을 줄이기 위해서라고 생각된다. 어느정도는 예외를 두지 않으면 작업양이 많아져서 힘들지 않을까 생각해본다.
  ```
  * 다형성
  ```
    특정 기능을 선언(설계)부분과 구현(동작)부분으로 분리한 후 구현부분을 다양한 방법으로 만들어 선택해서 사용할 수 있게 하는 기능이다. 선언 부분을 인터페이스라고도 할 수 있다. 개인적으로 이 설명은 아주 적절하다고 생각 하지만 다형성에 대해서 경험해보지 못한 사람이 이해하기엔 어색한 부분이 있지 않나 싶다. 왜 특정 기능을 분리하고, 인터페이스 같은 걸 써야하는지 이해할 수 없지 않을까. 그래서 더 이해가 쉽게 느껴지는 정의를 찾아봤다. 하나의 클래스나 메소드가 다양한 방식으로 동작이 가능한 것을 의미 한다는 설명이 있었다. 즉 하나의 클래스나 메소드가 다양한 방식으로 동작이 가능하게 하기 위해 기능을 나누고 인터페이스를 사용하려고 하는 것이다. 이렇게 하면 선언부분과 구현 부분은 1:N의 다형성 관계가 형성된다. 
  ```

  ```
    추가적으로 추상화(Abstraction)에 대해서도 적는다.
    추상화?
      객체들이 가진 공통의 특성들을 파악하고 불필요한 특성들을 제거하는 과정. 객체들이 가진 동작들을 기준으로 이용자들이 동작만 쉽게 구동할 수 있도록 한다. 속성 위주가 아닌 동작 위주로 정의하는 작업을 하는 것이다. 
      내가 본 글에서는 이렇게 속성 동작 위주로 정의하는 것을 추천한다. 동작에 연관되지 않는 속성은 불필요하다고 까지 말한다. 생각해보니 정말로 그렇다는 생각이 든다. 다음에 클래스 설계를 할 때는 진짜 동작위주로 속성을 정의해서 써봐야 겠다.
  ```
* 코드의 재사용
```
  클래스를 통해 인스턴스를 생성하는 것을 말한다고 생각이 된다. 그리고 여기에 이어지는 개념이 상속, 인터페이스와 같은 개념이라고 생각된다.
```

## Resources
* [MDN - Classes](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes)
* [MDN - Inheritance and the prototype chain](https://developer.mozilla.org/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
* [MDN - Inheritance](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Inheritance)
* [Polymorphism](https://medium.com/@viktor.kukurba/object-oriented-programming-in-javascript-3-polymorphism-fb564c9f1ce8)
* [Class Composition](https://alligator.io/js/class-composition/)
* [Inheritance vs Composition](https://woowacourse.github.io/javable/post/2020-05-18-inheritance-vs-composition/)

## Checklist
* 객체지향 프로그래밍은 무엇일까요?
  ```
    다형성, 캡슐화, 추상화등과 prototype 얘기하면서 신나게 한 것 같아서 짧게 내 생각만 적고 넘어가려고 한다. 현실의 개념을 프로그래밍으로 추상화, 구조화 하는 것이다. 추상화, 구조화된 객체들을 독립적으로 존재하고 이 객체들이 유기적으로 작동되게 함으로서 프로그램이 잘 돌아간다면 그게 객체지향 프로그래밍을 잘 구현해낸 것이 아닌가 싶다.
  ```
  * `#`로 시작하는 프라이빗 필드는 왜 필요한 것일까요? 정보를 은폐(encapsulation)하면 어떤 장점이 있을까요?
  ```
    이런저런 설명들을 몇 개 봤는데 나에게 가장 와닿은 것에 대해서 써보려고 한다. 내가 느끼는 가장 설득력 있었던 설명은 코드의 중복과 파편화를 피할 수 있다는 거였다. 속성들을 감추고 여기에 접근할 수 있는 메서드, 즉 기능만을 제공하기 때문이다. 예를 들어 width를 제공하고 width를 절반 나누는 기능을 그때 그때 만들어서 쓰게 되면 코드가 중복되고 사람에 따라서 다르게 코드를 작성하면서 파편화가 일어난다. 하지만 width를 캡슐화하고 width의 절반에 대한 getter를 제공하면 이런일을 막을 수 있다. 현실적으로 이런식의 개발을 백프로 한다는 것이 가능할까 싶기는 하지만 어느정도 하려고 노력하는건 해볼만 한 것 같다.
  ```
  * 다형성이란 무엇인가요? 다형성은 어떻게 코드 구조의 정리를 도와주나요?
  ```
    위에서 설명했기 때문에 간략하게 쓰겠다. 하나의 클래스나 기능이 여러가지 기능을 할 수 있도록 하는 것이다. 예를 들어 Animal이라는 인터페이스를 만들어 놓고 이것을 구현하는 Cat, Dog 등의 클래스를 만들면 Animal에 있는 똑같은 메서드라도 클래스마다 다른 기능으로 구현할 수 있다.
  ```
  * 상속이란 무엇인가요? 상속을 할 때의 장점과 단점은 무엇인가요?
  [상속과 합성](https://hue-dev.site/engineering/2021/05/20/%EC%83%81%EC%86%8D%EA%B3%BC-%ED%95%A9%EC%84%B1%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC.html)
  ```
    상위 클래스의 변수, 메서드를 하위 클래스에게 물려준다. 이를 통해 코드를 재사용 할 수 있다.
    장점?
    1. 코드의 중복이 적어진다.
    2. 확장이 쉬워진다.
    3. 코드의 통일성이 생긴다.
    4. 따라서 유지보수가 쉬워진다.

    단점?
    이런저런 단점들을 번호 달아서 설명 해준 글들이 많았다. 그렇게 와닿는다는 설명은 잘 보지 못했는데 좋은 설명을 찾았다. 모듈과 클래스는 높은 응집도와 낮은 결합력을 가져야 한다는 것인데 상속은 부모와 자식간에 높은 결합도를 가질 수 밖에 없다. 부모가 어떻게 변경되느냐에 따라서 자식은 영향을 받을 수 밖에 없는 것이다. 이렇게 자식이 부모변경에 취약해지는 현상을 Fragile Base Class Problem이라고 부른다고 한다.
  ```
  * OOP의 합성(Composition)이란 무엇인가요? 합성이 상속에 비해 가지는 장점은 무엇일까요?
  ```
    상속은 is-a, 합성은 has-a 관계라는데 글을 여러개 읽어봐도 사실 이해가 안된다. 예제코드를 제시하는데 내가 볼 땐 상속이던 합성이던 코드가 이상하더라. 내가 이해한 합성이라는 건 객체들을 관리할 수 있는 인터페이스를 만들고 이걸 구현해서 객체들을 주입받아 해결하는 방법인거 같다. 예를 들면 Steak 클래스와 Salad클래스가 있을 때 이것들의 가격을 계산 할 수 있는 CalcManager 클래스를 만들어서 Steak와 Salad의 가격을 계산해주면 될 것 같다.

    class Steak{}
    class Salad{}
    class CalcManager{
      constructor(steak, salad){
        let steak = steak;
        let salad = salad;
      }

      function calc(){
        return steak + salad;
      }
    }
    위와 같이 코드를 구성하는 것이다. 이렇게 하면 steak가격 방식이 변경 되더라도 유연하게 대체할 수 있다고 생각이 된다. 만약 이게 결합이 설명하는 방식이 아니더라도 지금까지 개발을 해오면서 이런식의 구조를 통해 문제를 해결해왔고 더 나은 방법을 찾지는 못했다. 앞으로 개발을 하다보면 결합에 대해서 더 잘 아는 사람을 만나거나 깨닫는 순간이 오겠지 싶다.
  ```
* 자바스크립트의 클래스는 어떻게 정의할까요?
  ```
    다음에 정리...
  ```
  * 프로토타입 기반의 객체지향 프로그래밍은 무엇일까요?
  ```
    위에서 적었다.
  ```
  * 자바스크립트의 클래스는 이전의 프로토타입 기반의 객체지향 구현과 어떤 관계를 가지고 있나요?
  ```
    질문이 정확히 무엇을 묻는지 약간 이해가 안되긴하는데 결국엔 함수로 구현되었고 프로토타입 기반의 템플릿이라는 거다. 
  ```

## Quest
* 웹 상에서 동작하는 간단한 바탕화면 시스템을 만들 예정입니다.
* 요구사항은 다음과 같습니다:
  * 아이콘은 폴더와 일반 아이콘, 두 가지의 종류가 있습니다.
  * 아이콘들을 드래그를 통해 움직일 수 있어야 합니다.
  * 폴더 아이콘은 더블클릭하면 해당 폴더가 창으로 열리며, 열린 폴더의 창 역시 드래그를 통해 움직일 수 있어야 합니다.
  * 바탕화면의 생성자를 통해 처음에 생겨날 아이콘과 폴더의 개수를 받을 수 있습니다.
  * 여러 개의 바탕화면을 각각 다른 DOM 엘리먼트에서 동시에 운영할 수 있습니다.
  * Drag & Drop API를 사용하지 말고, 실제 마우스 이벤트(mouseover, mousedown, mouseout 등)를 사용하여 구현해 보세요!

## Advanced
* 객체지향의 역사는 어떻게 될까요?
* Smalltalk, Java, Go, Kotlin 등의 언어들로 넘어오면서 객체지향 패러다임 측면에서 어떤 발전이 있었을까요?


{% include codepen.html hash="bGYxXLd" title="hello" %}

{% if page.comments %}
<div id="post-disqus" class="container">
{% include disqus.html %}
</div>
{% endif %}