---
layout: post
title: "브라우저 렌더링"
subtitle: ""
comments: true
categories : ETC
date: 2022-05-03
background: '/img/posts/06.jpg'
---
# 소개
이 글은 [IT Blog](https://realmojo.tistory.com/300) 블로그에서 정리된 내용을 바탕으로 개발자 면접질문들을 하나 씩 답해보고 견문을 넓히기 위해 작성합니다. 이번 글은 첫 번째 질문은 브라우저 렌더링에 관한 내용입니다.
네이버 D2에 올라온 [브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)를 참고하여 작성합니다.

## 브라우저의 주요 기능
사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것입니다. 보통은 HTML문서지만 PDF, 이미지 일 수 있습니다. 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해집니다.

## 브라우저의 기본 구조
  1. 사용자 인터페이스 - 주소표시줄, 이전/다음 버튼 등 요청 페이지를 제외한 나머지 부분
  2. 브라우저 엔진 - 사용자 인터페이스와 렌더링 렌진 사이의 동작을 제어
  3. 렌더링 엔진 - 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함
  4. 통신 - HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된
  5. UI 백엔드 - 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS사용자 인터페이스 체계를 사용.
  6. 자바스크립트 해석기 - 자바스크립트 코드를 해석하고 실행.
  7. 자료 저장소 - 자료를 저장하는 계층. 쿠키를 저장하는 것과 같이 모든 종류의 자우너을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 웹 데이터 베이스가 정의 되어 있다.
 
위의 7가지 내용은 D2의 원문 기준으로 작성한 내용입니다. 제가 이해한 내용을 토대로 정리해 보겠습니다.
  1. 브라우저는 크게 사용자 인터페이스와 사용자 화면 사이의 상호작용을 원활히 하도록 구성되어 있습니다. 
    - 이를 위해서 D2에서 정의하는 7가지의 브라우저 기본 구조가 필요합니다. 조금 더 풀어서 서술해보면 사용자 인터페이스에서 URI를 통해 자원을 받아오면 사용자 화면에 렌더링을 하기 위해 나머지 6가지의 요소들이 각자의 역할을 하는 것으로 이해됩니다. '사용자 인터페이스 -> URI를 통한 자원 -> 6가지 요소의 상호작용 -> 화면에 표시'
    - 브라우저의 기본 구조는 제 나름대로의 이해를 가졌다고 생각됩니다. 이제부터는 구조 별로 어떤 특성을 가졌고 어떤 역할을 하는지 서술해 보겠습니다.

## 렌더링 엔진
렌더링 엔진의 역할은 요청 받은 내용을 브라우저 화면에 표시하는 일입니다.
<br>
렌더링 엔진은 게코(모질라)와 웹킷(사파리, 크롬)이 있습니다.

### 동작 과정
렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8KB 단위로 전송됩니다.
렌더링 엔진의 기본적인 동작은 다음과 같습니다.
'DOM 트리 구축 위한 HTML 파싱 -> 렌더 트리 구축 -> 렌더 트리 배치 -> 렌더 트리 그리기'
위의 과정을 좀더 세부적으로 분석 해보겠습니다.

## 파싱과 DOM 트리 구축
파싱은 문서(HTML과 같은 문서)를 브라우저가 이해하고 사용할 수 있는 구조로 변환하는 것을 의미 합니다. 파싱의 결과는 보통 노드 트리인데 파싱트리 또는 문법 트리라고 부릅니다.
문서를 파싱하는 것은 다음의 과정으로 1차적인 세분화를 거칩니다.
'문서 -> 어휘분석 -> 구문분석 -> 파싱트리'
쉽게 말하면 파싱의 1차적인 세부 과정은 문서를 특정 분석 방법을 거쳐 파싱 트리로 만들어 낸다는 것입니다.
파싱의 1차적인 세분화가 끝났으니 다음 스텝이 필요합니다. 이를 '변환'이라고 부릅니다. 위의 1차 과정에서 만들어지 파싱트리는 최종 결과물이 아니기 때문에 변환의 과정을 통해 기계코드로 만들어 내야 합니다. 이렇게 까지 하면 파싱의 과정이 끝나게 됩니다.
위의 과정을 간단하게 정리 해보면  '소스코드 -> 파싱 -> 파싱트리 -> 변환 -> 기계코드' 입니다.

## DOM
Document Object Model의 줄임말 입니다. HTML 문서의 객체 표현이고 자바스크립트와 HTML의 연결 지점이라고도 볼 수 있습니다. DOM의 최상위 객체는 문서(document)입니다.
D2 글에는 DOM의 파싱 알고리즘 / 토큰화 알고리즘 / 트리 구축 알고리즘에 대한 설명이 잘 되어 있습니다. 해당 내용은 원문을 참고 하시면 될 것 같습니다.
알고리즘에 의해 파싱의 과정이 끝나게 되면 브라우저는 문서와 상호작용할 수 있는 상태가 됩니다. 이때 '지연'모드 스크립트를 파싱하기 시작합니다. 문서의 상태가 '완료'되면 '로드'이벤트가 발생합니다. 위와 같은 과정이 진행 되기 때문에 스크립트를 어디에 작성하는지에 따라 스크립트가 로드되고 안되고의 차이가 생긴다는 걸 알 수 있습니다. 

## 브라우저의 오류 처리
저희가 의식하지는 못하지만 브라우저는 오류 구문을 수정합니다. 아래 오류가 포함된 HTML이 있습니다.
```html
 <html>  
   <mytag></mytag>
   <div>
     <p>
   </div>
   Really lousy HTML
   </p>
</html>  
```
위 HTML은 2개의 오류가 있습니다. mytag는 표준 태그가 아니고 p, div는 중첩오류가 있습니다. 이런 오류가 있지만 파서는 이 오류를 수정하여 화면에 표시해줍니다.
파서는 적어도 다음과 같은 오류를 처리해야 합니다.
1. 어떤 태그의 안쪽에 추가하려는 태그가 금지된 것일 때 일단 허용된 태그를 먼저 닫고 금지된 태그는 외부에 추가한다.
2. 파서가 직접 요소를 추가해서는 안된다. 문서 제작자에 의해 뒤늦게 요소가 추가될 수 있고 생략 가능한 경우도 있다. HTML, HEAD, BODY, TBODY, TR, TD, LI 태그가 이런 경우에 해당한다.
3. 인라인 요소 안쪽에 블록 요소가 있는 경우 부모 블록 요소를 만날 때까지 모든 인라인 태그를 닫는다.
4. 이런 방법이 도움이 되지 않으면 태그를 추가하거나 무시할 수 있는 상태가 될 때까지 요소를 닫는다.
원문에 몇 가지 예시가 제시되어 있습니다. 이런 오류를 수정하는 것은 렌더링 엔진(크롬의 경우 웹킷)입니다.

## CSS 파싱
DOM이 다 만들어졌고 스크립트도 로드 하는 중입니다. 이제는 CSS가 적용되는 과정을 알아봐야 합니다. 일단 CSS를 정의된 어휘문법에 따라 구문 문법으로 만들어 냅니다. 자세한 내용은 원문을 참고 바랍니다. 만들어진 문법파일로부터 자동으로 파서를 생성하기 위해 플렉스와 바이슨 파서 생성기를 사용합니다.
![css 파싱](https://d2.naver.com/content/images/2015/06/helloworld-59361-12.png){width="500" height="500"}

## 스크립트와 스타일 시트의 진행 순서

### 스크립트
웹은 파싱과 실행이 동시에 수행되는 동기화 모델입니다. 제작자는 파서가 <scriipt> 태그를 만나면 즉시 파싱하고 실행하기를 기대합니다. 스크립트가 실행되는 동안 문서의 파싱은 중단됩니다. 스크립트가 외부에 있을 경우에도 실시간으로 네트워크에서 자우너을 가져오고 자원을 받을 때 까지 파싱은 중단됩니다. 이는 수 년간 지속 됐고 HTML4와 HTML5 명세에도 정의되어 있습니다. 제작자는 스크립트를 지연(defer)으로 표시할 수 있는데 지연으로 표시하면 문서 파싱은 중단되지 않고 파싱이 완료된 이후에 스크립트가 실행됩니다. HTML5는 스크립트를 비동기로 처히하는 속성도 추가했기 때문에 별도의 맥락에 의해 파싱되고 실행됩니다.
async와 defer의 공통점은 스크립트를 다운로드 하는 동안 문서의 파싱이 중단되지 않는 것 입니다. 참고로 다운로드 중 파싱이 중단되지 않는 것이고 다운로드가 완료된 후 async는 스크립트를 실행하기 때문에 HTML의 파싱이 멈추게 됩니다. 차이점은 스크립트의 실행에 있습니다. async는 스크립트 다운로드 후 바로 실행되고 defeer는 문서를 완전히 다 읽은 후에 실행합니다. 또 asyncn는 먼저 다운로드 된 순서대로 실행하고 defer는 정의된 순서대로 실행한다.
async
![async]()
defer
![defer]()
  
### 예측 파싱
최적화와 관련된 내용입니다. 스크립트를 실행하는 동안 다른 스레드는 네트워크로부터 다른 자원을 찾아 내려받고 문서의 나머지 부분을 파싱합니다. 이런 방법은 자우너을 병렬로 연결하여 받을 수 있고 전체적인 속도를 개선합니다. 하지만 예츨 파서는 DOM트리를 수정하지 않고 메인 파서의 일로 넘깁니다. 예측 파서는 외부 스크립트, 외부 스타일 시트와 외부 이미지와 같이 참조된 외부 자원을 파싱 할 뿐입니다.
  
### 스타일 시트
스타일 시트는 다른 모델을 사용합니다. 이론적으로 스타일 시트는 DOM트리를 변경하지 않아 문서 파싱을 기다리거나 중단할 이유가 없습니다. 하지만 스크립트가 문서 파싱 중에 정보를 요청하면 문제가 됩니다. 따라서 파이어폭스는 아직 로드 중이거나 파싱 중인 스타일 시트가 있는 경우 모든 스크립트의 실행을 중단합니다. 휍킷은 로드되지 않은 스타일 시트 가운데 문제가 될만한 속성이 있을 때만 스크립트를 중단 합니다.
  
## 

  


---

{% highlight ruby linenos %}
{% endhighlight %}

{% if page.comments %}
<div id="post-disqus" class="container">
{% include disqus.html %}
</div>
{% endif %}
