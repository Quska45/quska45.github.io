
# 1. 실시간 서버 모니터링 웹버전 개발 
- 역할 : 선임 개발자
- 인원구성 : 5-6명(인원 변경이 꾸준히 있었습니다.)
- 프로젝트 요약 : 기존 델파이로 개발 되어 있던 서버 모니터링 프로그램을 웹버전으로 전환하기 위해 새로운 웹 시스템을 구축하는 프로젝트 였습니다.
- 주요 담당 업무 요약 : 컴포넌트 설계 및 개발, 프론트 엔드 팀의 코드 품질 관리와 패키지 관리가 기본적인 업무 였습니다. 세부적으로는 제품의 메인 기능인 차트와 워커 + 웹소켓 프로그래밍을 맡아 개발했고 컴포넌트 별로 세부적인 기능정의와 문서작성 등의 업무를 진행했습니다.
- 기술 스택 : svelte, vite, node, typescript, storybook, tailwind, eslint, echarts, chartjs, flowbite, web worker, web socket

## 2. 참여기간
2022.12.05-2023.09.30

## 3. 고객사
팀스톤

## 4. 수행 업무
### 4-1. 워커 + 웹소켓 프로그래밍 설계 및 개발
모니터링 시스템은 실시간 모니터링이 가능해야 하기 때문에 성능을 위해 워커 + 웹소켓을 사용하는 것으로 설계 했습니다.
워커 내부적으로 소켓을 만들어 was로 부터 넘어오는 데이터의 병목을 최소화 했으며 워커 내부에서 데이터를 가공하는 과정을 통해 메인스레드의 부하를 줄이고 렌더링이 실시간으로 이뤄지도록 했습니다.
이런 목표를 달성하기 위해서 워커 + 소켓 프로그래밍에 대한 순서도를 작성하여 데이터의 흐름과 혹시 모를 버그의 가능성을 최소화 하고 팀 내부적으로 혼선이 없도록 했습니다.
워커 매니저라는 관리의 주체가 되는 클래스를 기반으로 하여 각 데이터타입별로 워커와 소켓을 만들어 워커 매니저가 이것들을 관리할 수 있도록 했습니다.
결과적으로 실시간으로 서버들에 대한 데이터가 발생될 때 마다 백엔드 -> was -> 프론트로 넘어오는 데이터들을 처리하여 프론트 엔드 개발자들이 사용할 수 있도록 제공했습니다.

### 4-2. WAS, BE 개발자들과 데이터에 대한 협의
개발팀은 내부적으로 3개의 팀으로 나뉘어 개발을 진행했습니다.
FE, WAS, BE 였는데 각 팀들간에 데이터를 어떤 식으로 전달하고 어떤 명세를 통해 주고 받을 지에 대한 협의가 필요했습니다.
저는 FE의 선임급 개발자로서 이런 명세를 다른 개발자들과 함께 정하고 조율하는 역할을 맡았습니다.
가장 기본적으로는 요청과 응답에 대한 명세를 정의했습니다.
요청과 응답의 경우 모든 데이터 타입에 대해 공통된 정의가 필요했고 이를 정의했습니다.
이런 부분들은 실무자로서 여러번 해왔던 것이기도 하고 구조 자체가 간단하여 크게 문제가 되는 부분은 없었던 것 같습니다.
기본적인 사항들이 정의되고 나서는 더 중요한 데이터 타입별 명세를 정의하는 일도 진행했습니다.
시스템의 베이스가 되는 서버들에 대한 정보, 이 서버들을 그룹화 하는 그룹에 대한 정보, 실시간 데이터등 세부 데이터들에 대한 명세를 다른 개발자들과 함께 정의 했습니다.

### 4-3. 프론트 팀 개발환경 구성 및 패키지 버전 관리
- 개발환경 : node(16ver), svelte(3->4ver), typescript(4->5ver), eslint(8ver), tailwind(3ver), vite(4ver), echarts(5ver), flowbite(1ver), storybook(7ver)

기존 델파이로 제작된 시스템을 웹버전으로 개발하려는 프로젝트의 목표가 있었기 때문에 환경을 새로 구성할 필요가 있었습니다.
먼저 번들러로 vite를 선택했습니다. 선정했던 이유는 빠른 빌드 속도가 가장 큰 이유 였습니다.
웹팩처럼 이미 보편화되어 있는 번들러와 비교하여 수십배의 속도 차이를 보여준다는 분석글이 워낙에 많아 선정을 하는데 큰 어려움은 없었습니다.
기존에 사용하고 있던 번들러를 vite로 마이그레이션 하는 것이 아니고 새로 적용만 시키면 되는 것이기 때문에 큰 부담이 없었던 것도 이유 중에 하나 였습니다.
사용성 측면에서도 웹팩과 크게 다르지 않았기 때문에 적용하는데 큰 문제가 없었습니다.
메인 프레임워크는 svelte를 선정했습니다. svelte를 선정한 가장 큰 이유도 성능에 대한 이점이 가장 큰 이유 였습니다.
빌드 타임에 코드를 해석해서 바닐라 스크립트로 코드를 만들어 주는 스벨트 이기 때문에 실시간으로 빠르게 데이터를 렌더링 해야하는 시스템에 더 적절하다고 판단 했습니다.
또 프레임워크를 위한 코드에 빌드에 포함 되는 다른 프레임워크에 비해 코드 번들의 사이즈 자체를 줄여준다는 것도 매력적인 옵션이었습니다.
추가로 델파이 개발자들이 웹으로 전향을 했기 때문에 새롭게 학습하는 과정이 필요 했기에 러닝커브가 낮다는 것도 선택의 이유 중 하나 였습니다.
결과적으로 아주 만족스러웠습니다.
그 외에 여러가지 라이브러리들을 조합하여 환경을 구성하고 시스템의 구성을 완성했습니다.
메인 프레임워크인 svelte의 버전업에 맞춰 typescript와 같은 관련 라이브러리들의 버전업 또한 진행해본 경험이 있습니다.

### 4-4. 베이스 차트 컴포넌트 설계 및 개발
차트는 실시간 모니터링 시스템의 필수적인 요소로 가장 메인이 되는 컴포넌트 중 하나 입니다.
차트는 굉장이 여러 종류가 필요한데 기본적인 라인/바 차트 부터 레이더/히트맵/게이지 차트 등 정말 다양한 차트가 필요했습니다.
이런 차트들을 매번 처음부터 새롭게 만드는 것은 매우 비효율 적이기 때문에 모든 차트가 가져야 하는 기본 기능들을 공통화 하는 베이스 차트 컴포넌트가 필요 했습니다.
베이스 차트는 기본적으로 모든 차트가 공통적으로 가져야하는 디자인적인 요소들을 정의할 수 있도록 했습니다.
색상, 간격, 폰트 크기 등 여러가지 디자인 요소들을 디자인 시스템에 맞게 적용했고 차트 개발자들이 차트별 특성에 맞게 변할 수 있도록 기능을 제공했습니다.
모든 차트는 사용자를 위해 옵션 팝업을 제공해야 했습니다. 예를 들어 차트의 색상을 바꾼다던디, 타이틀을 변경하는 등의 기능을 제공해야 했기 때문 입니다.
따라서 이런 것을 베이스 차트에서 제공하고 차트 개발자 들은 이를 활용해 차트를 개발하는데 들어가는 시간을 줄일 수 있었고 공통사항이 변경 됐을 때 일일이 수정하는 것이 아니라 베이스 차트만 변경하면 공통적으로 적용하여 개발 공수를 줄 일 수 있었습니다.

### 4-5. 실시간 라인차트 설계 및 개발
실시간 모니터링 시스템의 가장 메인이 되는 컴포넌트인 라인차트에 대한 설계와 개발을 진행했습니다.
성능이 가장 중요시 되는 컴포넌트인 만큼 초기에 많은 차트에 대해 성능을 측정하고 선정하는 것 부터 많은 노력을 했습니다.
high chart, canvasjs, chartjs, echarts, google charts 등 기업레벨에서 많이 사용되고 유명한 라이브러리들 부터 plotlyjs 처럼 비교적 유명하지 않은 차트 라이브러리들에 대한 성능 비교 까지 진행했습니다.
차트의 기본적인 성능을 동일한 환경에서 측정하고 비교 하기 위해 스토리북으로 만들어진 환경을 이용했습니다.
모든 차트는 라인차트를 이용했고 10초에 대한 1000라인을 그렸기 때문에 총 데이터 수는 1만개가 사용됐습니다.
인터벌을 이용해 1초에 한번씩 10초 간 렌더링이 일어났을 때 어느정도의 성능을 보여주는지 측정했습니다.
성능을 측정할 때는 크롬의 퍼포먼스 탭을 활용하여 렌더링시에 시간이 얼마나 걸리는지 정확하게 측정할 수 있었습니다.
결과적으로 echarts가 가장 준수한 성능을 보여줬고 기능적으로도 폭넓은 기능을 지원했기 때문에 선정하게 됐습니다.
이런 수치화된 정확한 판단을 기준으로 실시간 차트를 성공적으로 개발 할 수 있었습니다.

### 4-6. 코드 품질 관리 및 관리 전략 수립
기존에 코드형상관리를 하고 있지 않았기 때문에 새롭게 깃허브를 사용하게 되면서 어떤 식으로 코드 형상관리를 할 것이며 코드의 품질 관리를 어떤 식으로 할지에 대한 규칙을 정의 하는 것이 필요 했습니다.
기본적으로는 개발자들의 Pull Request에 대해 구글링을 통해 보편적으로 사용되는 라벨에 대한 컨벤션을 적용했습니다.
신규개발/유지보수에 대한 라벨, 현재 pr 진행상황, pr의 중요도에 대한 라벨, 코드리뷰를 누구에게 요청하는지를 명시할 수 있는 라벨등을 사용했습니다.
이런 라벨을 기반으로 FE팀에 코드리뷰가 정착되고 코드의 품질을 올릴 수 있도록 했습니다.
코드 내부적으로는 eslint, prettier, husky 등을 통해 코드 컨벤션에 대한 강제성을 부여하고 여러 개발자들이 비슷한 스타일의 코드를 작성할 수 있도록 만들 었습니다.

