
# 1. 실시간 서버 모니터링 웹버전 개발 
- 역할 : 선임 개발자
- 인원구성 : 5-6명(인원 변경이 꾸준히 있었습니다.)
- 프로젝트 요약 : 기존 델파이로 개발 되어 있던 서버 모니터링 프로그램을 웹버전으로 전환하기 위해 새로운 웹 시스템을 구축하는 프로젝트 였습니다.
- 주요 담당 업무 요약 : 컴포넌트 설계 및 개발, 프론트 엔드 팀의 코드 품질 관리와 패키지 관리가 기본적인 업무 였습니다. 세부적으로는 제품의 메인 기능인 차트와 워커 + 웹소켓 프로그래밍을 맡아 개발했고 컴포넌트 별로 세부적인 기능정의와 문서작성 등의 업무를 진행했습니다.
- 기술 스택 : svelte, vite, node, typescript, storybook, tailwind, eslint, echarts, chartjs, flowbite, web worker, web socket

## 2. 참여기간
2022.12.05-2023.09.30

## 3. 고객사
팀스톤

## 4. 수행 업무
### 4-1. 워커 + 웹소켓 프로그래밍 설계 및 개발
모니터링 시스템은 실시간 모니터링이 가능해야 하기 때문에 성능을 위해 워커 + 웹소켓을 사용하는 것으로 설계 했습니다.
워커 내부적으로 소켓을 만들어 was로 부터 넘어오는 데이터의 병목을 최소화 했으며 워커 내부에서 데이터를 가공하는 과정을 통해 메인스레드의 부하를 줄이고 렌더링이 실시간으로 이뤄지도록 했습니다.
이런 목표를 달성하기 위해서 워커 + 소켓 프로그래밍에 대한 순서도를 작성하여 데이터의 흐름과 혹시 모를 버그의 가능성을 최소화 하고 팀 내부적으로 혼선이 없도록 했습니다.
워커 매니저라는 관리의 주체가 되는 클래스를 기반으로 하여 각 데이터타입별로 워커와 소켓을 만들어 워커 매니저가 이것들을 관리할 수 있도록 했습니다.
결과적으로 실시간으로 서버들에 대한 데이터가 발생될 때 마다 백엔드 -> was -> 프론트로 넘어오는 데이터들을 처리하여 프론트 엔드 개발자들이 사용할 수 있도록 제공했습니다.

### 4-2. WAS, BE 개발자들과 데이터에 대한 협의
개발팀은 내부적으로 3개의 팀으로 나뉘어 개발을 진행했습니다.
FE, WAS, BE 였는데 각 팀들간에 데이터를 어떤 식으로 전달하고 어떤 명세를 통해 주고 받을 지에 대한 협의가 필요했습니다.
저는 FE의 선임급 개발자로서 이런 명세를 다른 개발자들과 함께 정하고 조율하는 역할을 맡았습니다.
가장 기본적으로는 요청과 응답에 대한 명세를 정의했습니다.
요청과 응답의 경우 모든 데이터 타입에 대해 공통된 정의가 필요했고 이를 정의했습니다.
이런 부분들은 실무자로서 여러번 해왔던 것이기도 하고 구조 자체가 간단하여 크게 문제가 되는 부분은 없었던 것 같습니다.
기본적인 사항들이 정의되고 나서는 더 중요한 데이터 타입별 명세를 정의하는 일도 진행했습니다.
시스템의 베이스가 되는 서버들에 대한 정보, 이 서버들을 그룹화 하는 그룹에 대한 정보, 실시간 데이터등 세부 데이터들에 대한 명세를 다른 개발자들과 함께 정의 했습니다.

### 4-3. 프론트 팀 개발환경 구성 및 패키지 버전 관리
- 개발환경 : node(16ver), svelte(3->4ver), typescript(4->5ver), eslint(8ver), tailwind(3ver), vite(4ver), echarts(5ver), flowbite(1ver), storybook(7ver)

기존 델파이로 제작된 시스템을 웹버전으로 개발하려는 프로젝트의 목표가 있었기 때문에 환경을 새로 구성할 필요가 있었습니다.
먼저 번들러로 vite를 선택했습니다. 선정했던 이유는 빠른 빌드 속도가 가장 큰 이유 였습니다.
웹팩처럼 이미 보편화되어 있는 번들러와 비교하여 수십배의 속도 차이를 보여준다는 분석글이 워낙에 많아 선정을 하는데 큰 어려움은 없었습니다.
기존에 사용하고 있던 번들러를 vite로 마이그레이션 하는 것이 아니고 새로 적용만 시키면 되는 것이기 때문에 큰 부담이 없었던 것도 이유 중에 하나 였습니다.
사용성 측면에서도 웹팩과 크게 다르지 않았기 때문에 적용하는데 큰 문제가 없었습니다.
메인 프레임워크는 svelte를 선정했습니다. svelte를 선정한 가장 큰 이유도 성능에 대한 이점이 가장 큰 이유 였습니다.
빌드 타임에 코드를 해석해서 바닐라 스크립트로 코드를 만들어 주는 스벨트 이기 때문에 실시간으로 빠르게 데이터를 렌더링 해야하는 시스템에 더 적절하다고 판단 했습니다.
또 프레임워크를 위한 코드에 빌드에 포함 되는 다른 프레임워크에 비해 코드 번들의 사이즈 자체를 줄여준다는 것도 매력적인 옵션이었습니다.
추가로 델파이 개발자들이 웹으로 전향을 했기 때문에 새롭게 학습하는 과정이 필요 했기에 러닝커브가 낮다는 것도 선택의 이유 중 하나 였습니다.
결과적으로 아주 만족스러웠습니다.
그 외에 여러가지 라이브러리들을 조합하여 환경을 구성하고 시스템의 구성을 완성했습니다.
메인 프레임워크인 svelte의 버전업에 맞춰 typescript와 같은 관련 라이브러리들의 버전업 또한 진행해본 경험이 있습니다.

### 4-4. 베이스 차트 컴포넌트 설계 및 개발
차트는 실시간 모니터링 시스템의 필수적인 요소로 가장 메인이 되는 컴포넌트 중 하나 입니다.
차트는 굉장이 여러 종류가 필요한데 기본적인 라인/바 차트 부터 레이더/히트맵/게이지 차트 등 정말 다양한 차트가 필요했습니다.
이런 차트들을 매번 처음부터 새롭게 만드는 것은 매우 비효율 적이기 때문에 모든 차트가 가져야 하는 기본 기능들을 공통화 하는 베이스 차트 컴포넌트가 필요 했습니다.
베이스 차트는 기본적으로 모든 차트가 공통적으로 가져야하는 디자인적인 요소들을 정의할 수 있도록 했습니다.
색상, 간격, 폰트 크기 등 여러가지 디자인 요소들을 디자인 시스템에 맞게 적용했고 차트 개발자들이 차트별 특성에 맞게 변할 수 있도록 기능을 제공했습니다.
모든 차트는 사용자를 위해 옵션 팝업을 제공해야 했습니다. 예를 들어 차트의 색상을 바꾼다던디, 타이틀을 변경하는 등의 기능을 제공해야 했기 때문 입니다.
따라서 이런 것을 베이스 차트에서 제공하고 차트 개발자 들은 이를 활용해 차트를 개발하는데 들어가는 시간을 줄일 수 있었고 공통사항이 변경 됐을 때 일일이 수정하는 것이 아니라 베이스 차트만 변경하면 공통적으로 적용하여 개발 공수를 줄 일 수 있었습니다.

### 4-5. 실시간 라인차트 설계 및 개발
실시간 모니터링 시스템의 가장 메인이 되는 컴포넌트인 라인차트에 대한 설계와 개발을 진행했습니다.
성능이 가장 중요시 되는 컴포넌트인 만큼 초기에 많은 차트에 대해 성능을 측정하고 선정하는 것 부터 많은 노력을 했습니다.
high chart, canvasjs, chartjs, echarts, google charts 등 기업레벨에서 많이 사용되고 유명한 라이브러리들 부터 plotlyjs


### 4-5. 코드 품질 관리 및 관리 전략 수립
프로젝트에 투입되고 나서 고객사에서 수립한 브랜치 관리 전략을 가이드 받았습니다.
- 1. development 브랜치에서 개발 브랜치 생성 
- 2. 개발 진행 및 완료
- 3. development 브랜치로 머지 후 기능 테스트
- 4. 개발브랜치에서 master 브랜치로 머지

위와 같은 식으로 브랜치를 관리했을 경우 불필요한 머지 이력이 마스터에 머지 되는 것과 같은 문제가 있기도 했고 충돌이 발생하는 경우에 development와 개발 브랜치가 머지 되어 검증되지 않은 기능이 master로 올라 갈 수도 있었습니다.
여러 협력사들의 개발이 진행되면서 development와 master의 환경 자체가 약간 씩 이원화 되어가고 있는 상황에서 development에서 검증을 거친 기능이 master에서는 작동할 수 없는 상황이 생기기도 했습니다.
따라서 git flow 전략을 제안했고 이를 기반으로 기존 브랜치 관리 전략에 약간의 커스텀을 통해 브랜치를 관리하기로 했습니다.

- 1. master 브랜치에서 개발 브랜치 생성
- 2. 개발 진행 및 완료
- 3. development 브랜치로 머지 후 기능 테스트
- 4. 개발브랜치에서 master 브랜치로 머지

master 브랜치에서 개발 브랜치를 생성한다는 약간의 변화 였지만 기존에 발생 했던 불필요한 머지 이력, 검증되지 않은 기능이 master브랜치에 올라가는 문제등을 막을 수 있었습니다.
realese 브랜치를 두고 관리할 수 있다면 좋았겠지만 고객사에서 관리자 부족 문제로 거절했었습니다.
하지만 막상 운영을 해보니 realese 브랜치가 없어도 관리상 큰 문제가 없었고 오히려 하나의 과정이 빠져서 더 용이하다는 느낌도 받았습니다.
단순히 깃을 사용하는 것이 아니라 어떻게 사용할지에 대해서 고민해볼 수 있는 경험이었습니다.
결과적으로 깃을 전혀 사용해본적이 없는 다른 개발자들과 표준을 정하여 혼란이 야기 되는 일 없이 정해진 프로세스 대로 코드리뷰와 머지가 이루어 질 수 있도록 했습니다.

### 4-6. 삼성전자 VOC 대응 및 처리
시스템을 운영하는 업무이다 보니 사용자가 발견한 버그를 처리하거나 업무에 대해 가이드 하는 역할도 맡고 있습니다.
주 단위로 봤을 때 다양한 사용자에게서 요청되는 수십건의 VOC들을 처리하고 있습니다.
그 과정에서 개발자가 아니신 분들도 있기 때문에 그 분들의 관점에서 가이드 드리면서 업무를 진행하고 있습니다.
결과적으로 1년 가까운 시간동안 미결로 남아있는 VOC 없이 성공적으로 시스템을 운영하고 있습니다.

