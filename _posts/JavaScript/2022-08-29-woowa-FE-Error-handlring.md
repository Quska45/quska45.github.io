---
layout: post
title: "티케의 프론트엔드에서의 에러 핸들링(10분 테코톡)"
subtitle: ""
comments: true
categories : Node
date: 2022-08-29
background: '/img/posts/06.jpg'
---

# 소개
우아한형제들의 유투브 채널인 `우아한Tech`에 올라온 프론트엔드의 에러 핸들링에 관한 영상을 바탕으로 글을 작성합니다.
9:34초의 영상입니다.
목차는 아래와 같습니다.
```
1. 용어 정의
2. 에러핸들링이 필요한 이유
3. 에러의 분류
4. 에러핸들링 예시
5. 에러핸들링에 대한 고찰
```

## 1. 용어 정의
원본 영상에서 설명하고자 하는 내용들에 대한 기본적인 용어 정의를 먼저 해보도록 하겠습니다.

### 1-1. 오류(에러)의 용어 정의
오류(에러)란 하드웨어의 고장 또는 소프트웨어가 본래의 동작을 할 수 없는 상태를 말합니다.
원본 영상에서 다루는 내용은 `소프트웨어가 본래의 동작을 할 수 없는 상태`에 대해서 입니다.
소프트웨어의 오류는 발생 시점에 따라 크게 2개로 나눌 수 있습니다.
- 컴파일 오류 : 코드가 컴파일 될 때 컴파일러가 해석하지 못해서 발생합니다.
- 런타임 오류 : 프로그램이 동작할 때 발견할 수 있는 에러입니다. 자바스크립트에서는 이를 예외 라고 부릅니다.

여기서 하나 알아 주실 점이 있습니다.
기본적으로 자바스크립트는 Dynamic Typed Language이기 때문에 모든 에러가 런타임 환경에서 발생합니다.

### 1-2. 예외의 용어 정의
일반적으로 런타임 오류와 관련된 것입니다. 예상하기 어렵거나 예상이 불가능한 이슈를 의미 합니다.
이런 예외가 발생되면 자바스크립트는 에러 객체를 내보내고 이에 대한 처리가 없다면 프로그램은 종료 됩니다.
따라서 예외로 인해 발생한 에러 객체를 핸들링하여 프로그램이 정상적으로 작동되게 해야 합니다.
이후에 영상에서 에러라고 표현되는 것은 모두 이 예외를 의미한다고 보시면 됩니다.

## 2. 에러 핸들링이 필요한 이유
먼저 서비스에 대한 부정적인 경험을 막기 위해서 입니다.
에러가 발생했을 때 아무 처리가 없다면 사용자는 무한정 기다릴 수 밖에 없기 때문입니다.
추가로 서비스의 트렌젝션에 영향을 미쳐 장애를 일으킬 수 있는 상황이 발생하는 것을 막을 수 있습니다.

## 3. 에러의 분류
먼저 어떤 에러들이 발생할 수 있는지 분류해 보도록 하겠습니다.

### 3-1. 예상이 가능한 에러
- 인증에러
- 잘못된 URL로 접근하는 에러
- 어플리케이션에서 정의한대로 API 응답의 상태 코드로 예측할 수 있는 에러
- 악의적인 목적으로 접근했을 때 이를 보완하는 코드가 프로그램에 내제되어 있지 않은 경우

이 외에도 많은 것들이 있을 수 있지만 여기서는 이 정도 예시만 드리도록 하겠습니다.

### 3-2. 예상이 불가능한 에러
- 서비스 장애
- 일시적인 네트워크가 불안정한 상황에서 발생하는 에러
- 상태코드 500대 에러

## 4. 에러핸들링 예시
이제 몇 가지 에러핸들링에 대한 예시를 보도록 하겠습니다.
try-catch-finally에 대해서 잘 모르신다면 이번 기회에 관련된 내용을 숙지하셔도 좋을 것 같습니다.

### 4-1. 예상할 수 있는 에러에 대한 예시
API 응답과 같은 에러는 상태 코드를 통해서 예외 상황을 구분할 수 있습니다.
하지만 같은 상태코드라도 다른 상황일 수 있으니 추가적으로 에러메시지도 전달하면 더 명확합니다.
만약 잘못된 URL로 접근하는 에러라면 에러페이지로 안내하는 것이 좋은 방법입니다.

### 4-2. 예상할 수 없는 에러에 대한 예시
일시적인 에러임을 알리는 것이 좋습니다.
또는 고객센터 등 상황을 공유할 수 있는 창구를 마련해야 합니다.

### 4-3. 에러트래킹
에러가 예상 가능/불가능을 떠나 에러를 트래킹하여 어떤 에러가 어디서 발생되는지 확인하는 것이 좋습니다.
원본 영상에서는 Sentry와 같은 도구를 사용하고 있다고 했습니다.

## 5. 에러핸들링에 대한 고찰
무조건 try-catch 하는 것은 지양하는 것이 좋습니다.
catch에 넘겨지는 error 객체는 에러에 따라 여러가지 값을 가질 수 있습니다.
따라서 타입이 보장되지 않아 또 다른 에러를 만들어 낼지도 모릅니다.
또 무작정 try-catch를 쓰는 것은 오류를 해결한다기 보다 숨기는 용도로 활용될지도 모릅니다.
따라서 다음과 같이 성공/실패에 대한 코드를 분리해서 실패하는 경우는 외부에 위임하는 것이 좋습니다.
먼저 try-catch를 막 사용한 안 좋은 예시를 보도록 하겠습니다.
```javascript
const checkAuth = async ( accessToken ) => {
  try {
    let user;
    try {
      user = await login( accessToken );
    } catch ( error ) {
      throw new Error( error, "존재하지 않는 유저입니다." );
    }
    
    return await getRole( user );
  } catch (error) {
    console.error( error, "권한이 없는 유저입니다." );
  }
}
```

위의 코드는 try-catch를 마구 사용해 가독성이 떨어질 뿐만 아니라,
성공/실패에 대한 로직이 섞여 있어 주요 기능이 무엇인지 알기도 어렵습니다.
이런 코드를 유지/보수 해야한다면 정말 한숨이 나올 것 같습니다.
그럼 이제 코드를 개선 해보겠습니다.

```javascript
const checkAuth = async ( accessToken ) => {
  const user = await login( accessToken );
  const role = await getRole( user );
  return role;
};

const UserPage = () => {
  ...
  
  try {
    checkAuth( accessToken );
  } catch ( error ) {
    // 에러 처리
    
  }
}
```


---
## 참고
- [](){: target="_blank"}


{% if page.comments %}
<div id="post-disqus" class="container">
{% include disqus.html %}
</div>
{% endif %}
